# JS中的作用域

## 一、作用域（scope）

**作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。**

**通俗地理解，作用域 就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。**

### 1、ES6以前的作用域

#### 全局作用域

全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。

#### 函数作用域

函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内 部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

#### 带来的问题

> 函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的**变量提升**。

##### 1. 变量容易在不被察觉的情况下被覆盖掉

##### 2. 本应销毁的变量没有被销毁

### 2、ES6引入块级作用域（let\const）

#### let和const

- let定义变量，不能var一个let过的变量，也不能let一个var/function/const过的变量
- const 定义常量

#### JavaScript 是如何支持块级作用域的

> 块级作用域就是通过词法 环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合， JavaScript 引擎也就同时支持了变量提升和块级作用域了。

1. 函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。
2.  通过 let 声明的变量，在编译阶段会被存放到**词法环境（Lexical Environment）**中。 
3. 在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用 域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息 就会从栈顶弹出，这就是**词法环境的结构**。
4. 在函数的作用域内部，通过 let 声明的变量只是创建被提升，此时，变量初始化并没有被提升，在变量初始化之前，会形成一个暂时性死区。。

### 3、作用域链

- 其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下 文，我们把这个外部引用称为outer。 
- 当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该 变量 
- 如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。
- 这个查找的链条就称为**作用域链**。

### 4、词法作用域

> **词法作用域**就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作 用域，通过它就能够预测代码在执行过程中如何查找标识符。

- 词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。

#### 块级作用域中的变量查找

- 当使用了一个在当前作用域中不存在的 变量，这时 JavaScript 引擎就需要按照作用域链在其他作用域中查找该变量

### 5、闭包

- **在 JavaScript 中，根据词法作用域的 规则，内部函数总是可以访问其外部函数中声明的变量，**
- **当通过调用一个外部函数返回一个 内部函数后，即使该外部函数已经执行结束了，**
- **但是内部函数引用外部函数的变量依然保存 在内存中，我们就把这些变量的集合称为闭包。**
- **比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。**

#### 闭包的回收

1. 通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这 个闭包以后不再使用的话，就会造成内存泄漏。
2.  如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。 
3. 所以在使用闭包的时候，注意一个原则：
   - 如果该闭包会一直使用，那么它可以作为全局变量而存在；
   - 如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。

## 二、this

### 1、this是什么？

![image-20200830205551659](E:\A极客时间\浏览器工作原理\JS中的作用域.assets\image-20200830205551659.png)

- this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this。

-  this 也只有三种——
  1. 全局执行上下文中的 this。
  2. 函数中的 this。
  3. eval 中的 this。

### 2、全局执行上下文中的 this

- 全局执行上下文中的 this 是指向 window 对象的。

- 这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。

### 3、函数执行上下文中的 this

- 明在默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的。

1. 通过函数的call方法设置：通过函数的call方法来设置函数执行上下文的 this 指向，还可以使用bind和apply方法来设置函数执行上下文中的 this
2. 通过对象调用方法设置：
   - 在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。 
   - 通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。

3. 通过构造函数中设置

- 当执行 [new](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new) CreateObj() 的时候，JavaScript 引擎做了如下四件事：
- 创建一个空的简单JavaScript对象（即**{}**）；
- 链接该对象（即设置该对象的构造函数）到另一个对象 ；
- 将步骤1新创建的对象作为**this**的上下文 ；
- 如果该函数没有返回对象，则返回**this**。
  1. 首先创建了一个空对象 tempObj； 
  2. 接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；
  3.  然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象； 
  4. 最后返回 tempObj 对象。

### 4、this 的设计缺陷以及应对方案

-  嵌套函数中的 this 不会从外层函数中继承
  1. 把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。
     - 这个方法的的本质是把 this 体系转换为了作用域的体系。
  2.  继续使用this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执 行上下文，所以它会继承调用函数中的 this。
- 普通函数中的 this 默认指向全局对象 window
  1. 如果要让函数执行上下 文中的 this 指向某个对象，最好的方式是通过 call 方法来显示调用。
  2. 通过设置 JavaScript 的“严格模式”来解决。
     - 函数的执行上下文中的 this 值是 undefined

### 5、总结

首先，在使用 this 时，为了避坑，要谨记以下三点： 

1. 当函数作为对象的方法调用时，函数中的 this 就是该对象； 
2. 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向 的是全局对象 window；
3. 嵌套函数中的 this 不会继承外层函数的 this 值。
4. 因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。