# 从URL到页面展示

![image-20200829162029717](E:\A极客时间\浏览器工作原理\从输入URL到页面展示.assets\image-20200829162029717.png)

### 大体流程

1. 用户从浏览器进程里输入请求信息； 
2. 网络进程发起 URL 请求； 
3. 服务器响应 URL 请求之后，浏览器进程就又要开始准备渲染进程了； 
4. 渲染进程准备好之后，需要先向渲染进程提交页面数据，我们称之为提交文档阶段；
5. 渲染进程接收完文档信息之后，便开始解析页面和加载子资源，完成页面的渲染。
6. **用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。**

### 详细流程

1. **用户输入**：地址栏输入查询关键字后，地址栏判断输入的关键字是**搜索内容**，还是**请求的URL**。
2. **URL请求**：
   1. 网络进程查找本地缓存是否缓存了该资源，
   2. 没有缓存进入网络请求流程
   3. DNS解析请求域名对应的IP地址
   4. 使用IP地址和服务器建立TCP连接
   5. 浏览器构建请求行，请求头等信息并把Cookie等数据加在请求头，向服务器发送请求
   6. 服务器接根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程
   7. 网络进程解析响应头的内 容了
      - 重定向：状态码是 301 或者 302
      - 响应数据类型处理：浏览器会根据 **Content-Type** 的值来决定如 何显示响应体的内容

3. **准备渲染进程**：

   - 默认情况下，Chrome 会为每个页面分配一个渲染进程
   - 一个页面打开了另一个新 页面，而**新页面和当前页面属于同一站点**的话，那么新页面会复用父页面的渲染进程。 process-per-site-instance

4. **提交文档**：

   1. “提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会 和网络进程建立传输数据的“管道”。 

   2. 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。 

   3. 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地 址栏的 URL、前进后退的历史状态，并更新 Web 页面。

      **到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。**

      #### 要点

      - 服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。 
      - Chrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这 两个标签会使用同一个渲染进程。 
      - 浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段

5. **渲染阶段**：

   ![image-20200830135520663](E:\A极客时间\浏览器工作原理\从输入URL到页面展示.assets\image-20200830135520663.png)

   1. 渲染进程将 HTML 内容转换为能够读懂的**DOM 树**结构。

   2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的**styleSheets**，计算出 DOM 节点的 样式。

   3.  创建**布局树**，并计算元素的布局信息。 

   4.  对布局树进行分层，并生成**分层树**:能够导致分层的元素属性参考以下

      - ```http
        https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context
        ```

   5. 为每个图层生成**绘制列表**，并将其提交到合成线程。

   6. 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图。

   7.  合成线程发送绘制图块命令**DrawQuad**给浏览器进程。

   8. 浏览器进程根据 DrawQuad 消息**生成页面**，并**显示**到显示器上。

      

- **特别注意**：
  1. 更新了元素的几何属性（重排）：重排需要**更新完整的渲染流水线**，所以开销也是最大的。
  2. 更新元素的绘制属性（重绘）：重绘**省去了布局和分层阶段**，所以执行效率会比重排操作要高 一些。
  3. 直接合成阶段：避开了布局和绘制两个子阶段，所以相对于重绘和重排，合 成能大大提升绘制效率。